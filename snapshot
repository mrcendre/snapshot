#!/bin/bash

#
# `snapshot`
#
#  An opinionated script for managing snapshots of a working copy from/to a remote server.
#
#  Setup: 
#	
#  Create a ~/.snapshot/config file with the following variables:
#
#    REMOTE_USER: Your FTP username.
#    REMOTE_PASS: Your FTP password (base64 encoded).
#    REMOTE_HOST: Your FTP host (e.g., ftp.example.com).
#    REMOTE_PORT: Your FTP port (default is 21).
#    REMOTE_PATH: The path on the FTP server where snapshots will be stored.
#
#  Usage:
#
#  snapshot [pack | push | pull] [-q | --quiet]
#
#  pack : Packs up a clean snapshot of the current working copy as a ZIP archive, named after the current directory.
#  push : Packs and uploads the snapshot to the remote server.
#  pull : Downloads the currently available snapshot from the remote server and replaces the current directory's contents with it.
#  -q, --quiet : Suppresses or reduces output messages.
#

# set -xe  # To debug commands
set -e

# Get the current working directory name
ROOT_DIR="$(pwd)"
PARENT_DIR="$(dirname "$ROOT_DIR")" # The parent directory of the current working directory
DIR_NAME="$(basename "$ROOT_DIR")" # The current working directory name
SNAPSHOT_NAME="$DIR_NAME" # ... which is used as the snapshot name

# Default parameters values
QUIET=false

# Colors and styles
ESC="\033["
RED="${ESC}1;31m"
GREEN="${ESC}1;32m"
YELLOW="${ESC}1;33m"
BLUE="${ESC}1;36m"
GREY="${ESC}38;5;250m"
DARK_GREY="${ESC}38;5;245m"
ITALIC="${ESC}3m"
ERASE_LINE="${ESC}2K"
END_STYLE="${ESC}0m"

# Configuration
CONFIG_PATH=~/.snapshot/config
DEFAULT_CONFIG="REMOTE_HOST=
REMOTE_PORT=
REMOTE_USER=
REMOTE_PASS=
REMOTE_PATH="

# Shows the command's usage information
show_usage() {
	printf "$GREY%s$END_STYLE\n\n" "Woops! Something's not right, check the script for guidance. Usage:"
	printf "\t%s\n\n" "snapshot [pack | push | pull] [-q | --quiet]"
	printf "\t%s\t\t%s\n" "pack" "Packs up a clean snapshot of the current working copy."
	printf "\t%s\t\t%s\n" "push" "Packs and uploads a snapshot to the remote server."
	printf "\t%s\t\t%s\n" "pull" "Downloads a snapshot from the remote server and replaces the current working copy with its content."
	printf "\t%s\t\t%s\n" "compare" "Compares the last modification time of both the local and remote snapshots,"
	printf "\t\t\t%s\n"           "determining if the local snapshot is newer or older than the remote one."
	printf "\t%s\t%s\n\n" "-q, --quiet" "Suppresses or reduces output messages."
	exit 1
}

# Parse arguments
ACTION=""
while [[ $# -gt 0 ]]; do
	case "$1" in
	pack)
		ACTION="pack"
		shift
		;;
	push)
		ACTION="push"
		shift
		;;
	pull)
		ACTION="pull"
		shift
		;;
	compare)
		ACTION="compare"
		shift
		;;
	-q | --quiet)
		QUIET=true
		shift
		;;
	*)
		show_usage
		;;
	esac
done

# Check if an action was specified, otherwise show usage
if [[ -z "$ACTION" ]]; then
	show_usage
fi

# Check if the config file exists
check_config() {
    if [ ! -f "$CONFIG_PATH" ]; then
        mkdir -p "$(dirname "$CONFIG_PATH")"
        touch "$CONFIG_PATH"
		echo "$DEFAULT_CONFIG" > "$CONFIG_PATH"
        printf "$RED%s$END_STYLE $GREY%s$END_STYLE\n" "Error!" "The config file $CONFIG_PATH did not exist and has been created."
        printf "Please fill it with your credentials, as described in the script header.\n\n"
        printf "$ITALIC%s$END_STYLE\n\n" "nano $CONFIG_PATH"
        exit 1
    fi

    # Load the .env-style file (KEY="value" lines). Quotes are handled correctly by 'source'.
    . "$CONFIG_PATH"

    # List of required, non-empty variables
    local required=(REMOTE_HOST REMOTE_PORT REMOTE_USER REMOTE_PASS REMOTE_PATH)
    local missing=()

    for var in "${required[@]}"; do
        # ${!var:-} expands to empty if unset; catches both unset and empty-string
        if [ -z "${!var:-}" ]; then
            missing+=("$var")
        fi
    done

    if ((${#missing[@]} > 0)); then
        printf "$RED%s$END_STYLE $GREY%s$END_STYLE\n" "Error!" "Missing or empty variables in $CONFIG_PATH."
		printf "Please fill it with your credentials, as described in the script header.\n"
		printf "Missing credentials:\n"

        for m in "${missing[@]}"; do
            printf "  - %s\n" "$m"
        done
        exit 1
    fi
}

#
# Retrieves the last modification time for both the remote and local snapshots, to determine which one is newer.
#
compare() {

	check_config

	printf "$BLUE%s$END_STYLE %s\n" \
			"Let's see!" \
			"Comparing local and remote snapshots last modification dates."

	# Download the snapshot from the FTP server
	source $CONFIG_PATH
	FILENAME="$SNAPSHOT_NAME.zip"
	
	REMOTE_FILE="$REMOTE_PATH/$FILENAME"

	CURRENT_DATE=$(date +%d/%m/%Y)
	CURRENT_TIME=$(date +%H:%M:%S)

	# Check the local working copy's last modification time
	start_timer "Checking local working directory (may take a while for large projects)..."
	local_timestamp=$(check_local_modification_time)
	sleep 2.2
	stop_timer

	# Check the remote server's last modification time
	start_timer "Checking remote snapshot..."
	remote_timestamp=$(check_remote_modification_time)
	stop_timer

	# Format the timestamps to a human-readable format
	local formatted_local=""
	local formatted_remote=""

	# Determine which of the remote snapshot or local copy is newer
	if [ -n "$local_timestamp" ]; then
		formatted_local=$(format_timestamp "$local_timestamp")
		local_epoch=$(to_epoch "$local_timestamp")
	fi

	if [ -n "$remote_timestamp" ]; then
		formatted_remote=$(format_timestamp "$remote_timestamp")
		remote_epoch=$(to_epoch "$remote_timestamp")
	fi

	
	# Initialize suffixes
	remote_suffix=""
	local_suffix=""
	hint=""

	# If the remote snapshot doesn't exist, print a custom message
	if [ -z "$remote_timestamp" ]; then
		printf "%s $YELLOW%s$END_STYLE %s\n" "The" "remote snapshot $REMOTE_PATH/$FILENAME does not exist."
		exit 1
	fi

	if (( remote_epoch > local_epoch )); then
		remote_suffix="(latest)"
		outcome=$(printf "%s $YELLOW%s$END_STYLE %s\n" "The" "remote snapshot is newer" "than the local working copy.")
		hint="You may have some changes to pull, or have just pushed a snapshot."
	elif (( remote_epoch < local_epoch )); then
		local_suffix="(latest)"
		outcome=$(printf "%s $YELLOW%s$END_STYLE %s\n" "The" "local working copy is newer" "than the remote snapshot.")
		hint="You are likely up to date — remember to push when you're done!"
	else
		outcome="Weird, both the local working copy and the remote snapshot have the same modification time..."
		hint="That's pretty uncommon, please double check the contents to be sure!"
	fi

	#### Print the results
	printf "\n"
	printf "\t%-8s %-20s\n" 			       "Source" "Last modification time"
	printf "\t%-8s %-20s\n"				       "======" "========================================"
	printf "\t%-8s %-20s $GREEN%s$END_STYLE\n" "Remote" "$formatted_remote" "$remote_suffix"
	printf "\t%-8s %-20s $GREEN%s$END_STYLE\n" " Local" "$formatted_local" "$local_suffix"
	printf "\n"
	printf "  → $outcome\n"
	printf "    $hint\n\n"
}

#
# Checks the remote server's last modification time for the snapshot file.
#
check_remote_modification_time() {

	# Get current year for filling missing years
	current_year=$(date +%Y)

	# Get the directory listing from the FTPES server
	# Note: the trailing slash in $REMOTE_PATH is important for the listing to work correctly
	listing=$(curl --insecure --tlsv1.2 --ftp-ssl-control -s \
		--user "$REMOTE_USER:$(echo "$REMOTE_PASS" | base64 --decode)" \
		"ftp://$REMOTE_HOST:$REMOTE_PORT/$REMOTE_PATH/")

	# Extract the matching file/folder line
	line=$(printf '%s\n' "$listing" | grep -E "[[:space:]]$FILENAME\$")

	# If the remote snapshot does not exists, return a splat 0 timestamp
	# This way, the local snapshot will always appear newer.
	if [[ -z $line ]]; then
		return
	fi

	# Parse the month, day, and time/year fields
	month=$(echo "$line" | awk '{print $6}')
	day=$(echo "$line" | awk '{print $7}')
	time_or_year=$(echo "$line" | awk '{print $8}')

	# Decide whether it's a time (contains ':') or a year
	if [[ $time_or_year =~ : ]]; then
		# Format: Month Day Time (no year) - we assume the current year
		year=$current_year
		time=$time_or_year
	else
		# Format: Month Day Year (no time) - we set the time to midnight
		year=$time_or_year
		time="00:00"
	fi

	# Format timestamp to ISO 8601, based on the OS
	if [[ "$(uname)" == "Darwin" ]]; then
		# macOS / BSD date syntax
		remote_timestamp=$(date -j -f "%b %d %Y %H:%M" "$month $day $year $time" "+%Y-%m-%d %H:%M:%S")
	else
		# GNU date syntax (Linux)
		remote_timestamp=$(date -d "$month $day $year $time" "+%Y-%m-%d %H:%M:%S")
	fi

	echo $remote_timestamp
}

#
# Checks the latest local modification time in the working copy.
#
check_local_modification_time() {

	# Pick the right stat command for the OS
	local stat_epoch
	if [[ "$(uname)" == "Darwin" ]]; then
		stat_epoch='stat -f %m --'
	else
		stat_epoch='stat -c %Y --'
	fi

	local latest_file=""
	local latest_m=-1

	# A list of directories to exclude, where open programs such as VS Code could make unexpected changes,
	# leading to erroneous results in the latest modification time — we only want to check the source files.
	# This concerns Dart, Flutter, Node.js and Rust projects, but can be extended by adding folders to this list.
	EXCLUDES=(node_modules build target .dart_tools)

	# Build the find prune expression dynamically
	prune_expr=()
	for d in "${EXCLUDES[@]}"; do
		prune_expr+=( -name "$d" -o )
	done
	# Remove trailing -o
	unset 'prune_expr[${#prune_expr[@]}-1]'

	# Loop over all files safely (null-delimited), excluding dirs in EXCLUDES
	while IFS= read -r -d '' f; do
		local m
		m=$($stat_epoch "$f" 2>/dev/null) || m=0
		[[ "$m" =~ ^[0-9]+$ ]] || m=0
		if (( m > latest_m )); then
			latest_m=$m
			latest_file="$f"
		fi
	done < <(
		find "." \
			-type d \( "${prune_expr[@]}" \) -prune \
			-o -type f -print0 2>/dev/null
	)

	# If the working copy is empty, default to a splat 0 timestamp,
	# so the remote always appears newer.
	if [[ -z "$latest_file" ]]; then
		return
	fi

	# Format timestamp in UTC, picking right date syntax
	local local_timestamp
	if local_timestamp=$(date -u -r "$latest_m" +%Y-%m-%d\ %H:%M:%S 2>/dev/null); then
		:
	else
		local_timestamp=$(date -u -d "@$latest_m" +%Y-%m-%d\ %H:%M:%S)
	fi

	echo $local_timestamp

}

#
# Converts a UTC timestamp to a human-friendly string in LOCAL timezone.
# Accepts: "YYYY-MM-DD HH:MM:SS" or "YYYY-MM-DDTHH:MM:SSZ"
#
format_timestamp() {
  local ts="$1"
  local os; os="$(uname)"
  local out_fmt="+%A %d %B %Y at %H:%M:%S (%Z)"
  local epoch in_fmt

  if [[ "$ts" == *Z ]]; then
    in_fmt="%Y-%m-%dT%H:%M:%SZ"
  else
    in_fmt="%Y-%m-%d %H:%M:%S"
  fi

  if [[ "$os" == "Darwin" ]]; then
    # Step 1: parse as UTC -> epoch
    epoch=$(date -j -u -f "$in_fmt" "$ts" +%s 2>/dev/null) || { echo "Invalid timestamp: $ts" >&2; return 1; }
    # Step 2: format epoch in LOCAL time
    date -r "$epoch" "$out_fmt"
  else
    # GNU coreutils
    [[ "$ts" == *Z ]] || ts="$ts UTC"   # make sure GNU date knows it's UTC
    epoch=$(date -u -d "$ts" +%s 2>/dev/null) || { echo "Invalid timestamp: $ts" >&2; return 1; }
    date -d "@$epoch" "$out_fmt"
  fi
}

# 
# Convert to epoch seconds (macOS and Linux compatible)
#
to_epoch() {
    local ts="$1"
    # Try GNU date first, then BSD/macOS date
    date -u -d "$ts" +%s 2>/dev/null || \
    date -u -j -f "%Y-%m-%d %H:%M:%S" "$ts" +%s
}

# Start the timer in the background; optional message
start_timer() {
  TIMER_MSG="${1:-Working}"
  TIMER_STARTED_EPOCH=$(date +%s)
  tput civis 2>/dev/null || true

  (
    # Exit cleanly when asked to stop
    trap 'exit 0' TERM INT
    local ticks=1
    while :; do
      printf "\r${ERASE_LINE}${DARK_GREY}→ %s (%d sec)$END_STYLE" "$TIMER_MSG" "$ticks" 1>&2

      #printf "\r$ERASE_LINE $DARK_GREY→ %s (%d sec)$END_STYLE" "$TIMER_MSG" "$ticks" 1>&2

      sleep 1
      ticks=$((ticks + 1))
    done
  ) &
  TIMER_PID=$!

  # Restore cursor even if script exits unexpectedly
  trap 'stop_timer' EXIT
}

# Stop the timer
stop_timer() {
  [[ -n "$TIMER_PID" ]] || return 0

  # Ask the loop to exit
  kill -TERM "$TIMER_PID" 2>/dev/null || true

  # Give it a moment to die; then force-kill if needed
  for _ in 1 2 3 4 5; do
    kill -0 "$TIMER_PID" 2>/dev/null || break
    sleep 0.02
  done
  kill -KILL "$TIMER_PID" 2>/dev/null || true

  # Reap it
  wait "$TIMER_PID" 2>/dev/null || true
  TIMER_PID=

  # Print final line with total time in (0.00 sec)
  local end_time=$(date +%s)
  local total=$(( end_time - TIMER_STARTED_EPOCH ))
  local seconds=$(( total % 60 ))
  local millis=$(( (total * 10) % 10 ))

  printf "\r${ERASE_LINE}${DARK_GREY}✔ %s (%d sec.)$END_STYLE\n" "${TIMER_MSG:-Done}" "$seconds" 1>&2

  tput cnorm 2>/dev/null || true
  trap - EXIT
}

#
# Packs up a clean snapshot of the current working copy as a ZIP archive, named after the current directory.
#
pack() {
	$QUIET || echo "Packing up snapshot..."
	
	# Perform `flutter clean` if relevant
	if command -v flutter &> /dev/null; then  # Check if Flutter is installed
		if [ -f "pubspec.yaml" ]; then # Check if the pubspec.yaml file exists
			start_timer "Flutter project detected, cleaning..."
			flutter clean
			stop_timer
		fi
	fi

	# Zip up the entire parent folder at the parent folder's level
	cd "$PARENT_DIR"
	start_timer "Zipping up the archive"
	zip -r -q "$SNAPSHOT_NAME.zip" "$DIR_NAME"
	stop_timer

	printf "\n"

	# If not in quiet mode, print the archive path and reveal it in Finder
	if [ "$QUIET" = false ]; then
		echo "Snapshot archive is available at $PARENT_DIR/$SNAPSHOT_NAME.zip"
		open -R "$PARENT_DIR/$SNAPSHOT_NAME.zip"
	fi
}

# 
# Packs up the current local working copy and uploads the snapshot to the remote server.
#
push() {

	check_config

	CURRENT_DATE=$(date +%d/%m/%Y)
	CURRENT_TIME=$(date +%H:%M:%S)

	# Upload the snapshot to the FTP server
	printf "\nPushing snapshot ($CURRENT_DATE at $CURRENT_TIME)...\n\n"

	# Pack the snapshot
	WAS_QUIET=$QUIET
	QUIET=true
	pack
	QUIET=$WAS_QUIET


	# Upload the snapshot to the FTP server
	printf "${DARK_GREY}↑ Uploading to remote...$END_STYLE\n\n"

	source $CONFIG_PATH
	cd ..

	FILENAME="$SNAPSHOT_NAME.zip"
	URL_SAFE_FILENAME=$(python3 -c "import urllib.parse, sys; print(urllib.parse.quote(sys.argv[1]))" "$FILENAME")
	LOCAL_FILE="$PARENT_DIR/$FILENAME"

	printf "$DARK_GREY"
	curl --insecure --tlsv1.2 --ftp-ssl-control \
		--user "$REMOTE_USER:$(echo "$REMOTE_PASS" | base64 --decode)" \
		-T "$LOCAL_FILE" \
		"ftp://$REMOTE_HOST:$REMOTE_PORT/$REMOTE_PATH/$URL_SAFE_FILENAME"
	printf "$END_STYLE\n"

	# Remove the local file
	start_timer "Cleaning up..."
	rm "$LOCAL_FILE"
	stop_timer

	printf "\n"

	printf "$GREEN%s$END_STYLE $GREY%s$END_STYLE\n\n" "Good to go!" "The snapshot has been uploaded successfully. Have a pleasant day!"
}

#
# Downloads the snapshot from the remote server and replaces the current working copy with it.
#
pull() {
	
	check_config

	CURRENT_DATE=$(date +%d/%m/%Y)
	CURRENT_TIME=$(date +%H:%M:%S)

	printf "$YELLOW%s$END_STYLE $GREY%s$END_STYLE\n\n" "Warning!" "This is a destructive operation, hit Ctrl+C to cancel."
	printf "Pulling snapshot ($CURRENT_DATE at $CURRENT_TIME)...\n\n"

	# Download the snapshot from the FTP server
	source $CONFIG_PATH
	FILENAME="$SNAPSHOT_NAME.zip"
	URL_SAFE_FILENAME=$(python3 -c "import urllib.parse, sys; print(urllib.parse.quote(sys.argv[1]))" "$FILENAME")

	LOCAL_DIR="$ROOT_DIR/../"
	
	TEMP_DIR=$(mktemp -d)
	TEMP_FILE="$TEMP_DIR/$FILENAME"

	REMOTE_FILE="$REMOTE_PATH/$URL_SAFE_FILENAME"
	
	printf "${DARK_GREY}↓ Downloading from remote...\n\n"
	curl --insecure --tlsv1.2 --ftp-ssl-control \
		--user "$REMOTE_USER:$(echo "$REMOTE_PASS" | base64 --decode)" \
		-o "$TEMP_FILE" \
		"ftp://$REMOTE_HOST:$REMOTE_PORT/$REMOTE_FILE"
	printf "$END_STYLE\n"
	
	# Extract the downloaded snapshot
	start_timer "Cleaning working directory..."
	find "." -mindepth 1 -maxdepth 1 ! -name ".env" -exec rm -rf {} +
	stop_timer

	start_timer "Extracting..."
	unzip -o -q "$TEMP_FILE" -d "$LOCAL_DIR"
	stop_timer

	# Clean up the downloaded snapshot
	start_timer "Cleaning up..."
	rm -rf $TEMP_DIR
	stop_timer

	printf "\n$GREEN%s$END_STYLE $GREY%s$END_STYLE\n\n" \
		   "We're all set!" \
		   "When editing with VS Code, don't forget to run the \"Developer: Reload window\" command to refresh the workspace's files and extensions."
}

case "$ACTION" in
pack) pack ;;
push) push ;;
pull) pull ;;
compare) compare ;;
*) show_usage ;;
esac

